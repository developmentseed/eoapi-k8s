# eoAPI Production Profile
# Production-ready deployment with autoscaling and observability
# Includes: All core services, monitoring stack, autoscaling, and observability
#
# Usage:
#   helm install eoapi ./charts/eoapi -f profiles/production.yaml
#   helm upgrade eoapi ./charts/eoapi -f profiles/production.yaml
#
# Prerequisites:
#   - Configure ingress.host with your domain
#   - Ensure metrics-server is available in your cluster
#   - Review and adjust resource allocations based on your workload

######################
# DATABASE
######################
# Production PostgreSQL configuration
postgresql:
  type: "postgrescluster"

postgrescluster:
  enabled: true
  postgresVersion: 16
  postGISVersion: "3.4"
  pgBouncerReplicas: 2  # HA setup
  monitoring: true      # Enable PostgreSQL metrics
  instances:
    - name: eoapi
      replicas: 2  # High availability
      dataVolumeClaimSpec:
        accessModes:
          - "ReadWriteOnce"
        resources:
          requests:
            storage: "50Gi"  # Production storage
      resources:
        requests:
          cpu: "2048m"
          memory: "4096Mi"
        limits:
          cpu: "4096m"
          memory: "8192Mi"
  users:
    - name: postgres
      databases:
        - eoapi
        - postgres
      options: "SUPERUSER"
    - name: eoapi
      databases:
        - eoapi
        - postgres
      options: "CREATEDB CREATEROLE"
      password:
        type: AlphaNumeric

######################
# PGSTAC BOOTSTRAP
######################
pgstacBootstrap:
  enabled: true
  settings:
    loadSamples: false  # No samples in production

    # Production PgSTAC settings
    pgstacSettings:
      queue_timeout: "10 minutes"
      use_queue: "false"
      update_collection_extent: "true"
      context: "auto"
      context_estimated_count: "100000"
      context_estimated_cost: "100000"
      context_stats_ttl: "1 day"

    resources:
      requests:
        cpu: "1024m"
        memory: "2048Mi"
      limits:
        cpu: "2048m"
        memory: "4096Mi"

######################
# MONITORING & METRICS
######################
# Essential for autoscaling and observability
monitoring:
  metricsServer:
    enabled: true
    apiService:
      create: true

  prometheus:
    enabled: true
    alertmanager:
      enabled: false  # Use Grafana alerting instead
    prometheus-pushgateway:
      enabled: false
    kube-state-metrics:
      enabled: true
    prometheus-node-exporter:
      enabled: true
      resources:
        limits:
          cpu: "50m"
          memory: "64Mi"
        requests:
          cpu: "50m"
          memory: "64Mi"
    server:
      persistentVolume:
        enabled: true
        size: 30Gi
      retention: "15d"
      resources:
        limits:
          cpu: "1000m"
          memory: "2048Mi"
        requests:
          cpu: "500m"
          memory: "1024Mi"
      service:
        type: ClusterIP

# Custom metrics for request-rate based autoscaling
prometheusAdapter:
  enabled: true
  resources:
    limits:
      cpu: "200m"
      memory: "256Mi"
    requests:
      cpu: "100m"
      memory: "128Mi"

######################
# OBSERVABILITY
######################
observability:
  grafana:
    enabled: true
    persistence:
      enabled: true
      size: 10Gi
    service:
      type: ClusterIP
    resources:
      limits:
        cpu: "200m"
        memory: "256Mi"
      requests:
        cpu: "100m"
        memory: "128Mi"
    datasources:
      datasources.yaml:
        apiVersion: 1
        datasources:
          - name: Prometheus
            type: prometheus
            url: "http://{{ .Release.Name }}-prometheus-server"
            access: proxy
            isDefault: true

######################
# API SERVICES WITH AUTOSCALING
######################
stac:
  enabled: true
  ingress:
    enabled: true
    path: "/stac"
  autoscaling:
    enabled: true
    minReplicas: 2      # HA minimum
    maxReplicas: 20
    type: "both"        # CPU and request rate
    behavior:
      scaleDown:
        stabilizationWindowSeconds: 300  # 5 minutes
      scaleUp:
        stabilizationWindowSeconds: 30
    targets:
      cpu: 70
      requestRate: 50000m  # 50 req/sec per pod
  settings:
    resources:
      requests:
        cpu: "750m"
        memory: "1536Mi"
      limits:
        cpu: "1500m"
        memory: "3072Mi"
    envVars:
      HOST: "0.0.0.0"
      PORT: "8080"
      WEB_CONCURRENCY: "6"
      STAC_FASTAPI_DEBUG: "False"
      STAC_FASTAPI_CORS_ORIGINS: '["*"]'

raster:
  enabled: true
  ingress:
    enabled: true
    path: "/raster"
  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 15
    type: "both"
    behavior:
      scaleDown:
        stabilizationWindowSeconds: 300
      scaleUp:
        stabilizationWindowSeconds: 60
    targets:
      cpu: 60  # Lower due to resource intensity
      requestRate: 30000m  # 30 req/sec per pod
  settings:
    resources:
      requests:
        cpu: "1024m"
        memory: "3072Mi"
      limits:
        cpu: "2048m"
        memory: "6144Mi"
    envVars:
      # GDAL optimization
      GDAL_CACHEMAX: "512"
      GDAL_DISABLE_READDIR_ON_OPEN: "EMPTY_DIR"
      GDAL_INGESTED_BYTES_AT_OPEN: "32768"
      GDAL_HTTP_MERGE_CONSECUTIVE_RANGES: "YES"
      GDAL_HTTP_MULTIPLEX: "YES"
      GDAL_HTTP_VERSION: "2"
      GDAL_HTTP_MAX_RETRY: "3"
      GDAL_HTTP_RETRY_DELAY: "1"
      GDAL_SKIP: "VRT"
      PYTHONWARNINGS: "ignore"
      VSI_CACHE: "TRUE"
      VSI_CACHE_SIZE: "5000000"
      # Uvicorn settings
      HOST: "0.0.0.0"
      PORT: "8080"
      WEB_CONCURRENCY: "4"
      TITILER_DEBUG: "False"

vector:
  enabled: true
  ingress:
    enabled: true
    path: "/vector"
  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 10
    type: "both"
    behavior:
      scaleDown:
        stabilizationWindowSeconds: 240
      scaleUp:
        stabilizationWindowSeconds: 45
    targets:
      cpu: 75
      requestRate: 75000m  # 75 req/sec per pod
  settings:
    resources:
      requests:
        cpu: "512m"
        memory: "1024Mi"
      limits:
        cpu: "1024m"
        memory: "2048Mi"
    envVars:
      TIPG_CATALOG_TTL: "300"
      TIPG_DEBUG: "False"
      HOST: "0.0.0.0"
      PORT: "8080"
      WEB_CONCURRENCY: "6"

# Optional: Enable if you need multidimensional support
multidim:
  enabled: false
  ingress:
    enabled: true
    path: "/multidim"
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 5
    type: "cpu"  # CPU-only due to resource intensity
    targets:
      cpu: 50
  settings:
    resources:
      requests:
        cpu: "2048m"
        memory: "8192Mi"
      limits:
        cpu: "4096m"
        memory: "16384Mi"
    envVars:
      GDAL_CACHEMAX: "1024"
      GDAL_DISABLE_READDIR_ON_OPEN: "EMPTY_DIR"
      GDAL_INGESTED_BYTES_AT_OPEN: "32768"
      GDAL_HTTP_MERGE_CONSECUTIVE_RANGES: "YES"
      GDAL_HTTP_MULTIPLEX: "YES"
      GDAL_HTTP_VERSION: "2"
      PYTHONWARNINGS: "ignore"
      VSI_CACHE: "TRUE"
      VSI_CACHE_SIZE: "10000000"
      HOST: "0.0.0.0"
      PORT: "8080"
      WEB_CONCURRENCY: "2"

######################
# UI COMPONENTS
######################
browser:
  enabled: true
  replicaCount: 2  # HA setup
  settings:
    resources:
      requests:
        cpu: "50m"
        memory: "64Mi"
      limits:
        cpu: "100m"
        memory: "128Mi"

docServer:
  enabled: true

######################
# OPTIONAL FEATURES
######################
# Disable experimental features in production
eoapi-notifier:
  enabled: false

knative:
  enabled: false

######################
# INGRESS
######################
ingress:
  enabled: true
  className: "nginx"
  pathType: "Prefix"
  host: "eoapi.example.com"  # CHANGE THIS to your domain
  tls:
    enabled: true
    secretName: eoapi-tls
    # certManager: true  # Uncomment if using cert-manager

######################
# SECURITY & RBAC
######################
serviceAccount:
  create: true
  automount: true
  annotations: {}
    # Add cloud provider annotations if needed
    # eks.amazonaws.com/role-arn: arn:aws:iam::ACCOUNT:role/eoapi-role

######################
# GENERAL SETTINGS
######################
service:
  port: 8080

# Enable autoscaling globally
autoscaling:
  enabled: true

# Connection pooling for better performance
database:
  enabled: true
  connectionPooling:
    enabled: true
